# Supabase Database Schema

This document describes the database schema required for the Northstar backend to track proposals, experiments, and activity logs.

## Required Tables

### 1. `repositories`

Stores connected GitHub repositories.

```sql
CREATE TABLE repositories (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  repo_fullname TEXT UNIQUE NOT NULL,
  owner TEXT NOT NULL,
  repo_name TEXT NOT NULL,
  default_branch TEXT DEFAULT 'main',
  base_branch TEXT DEFAULT 'main',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_repositories_repo_fullname ON repositories(repo_fullname);
CREATE INDEX idx_repositories_is_active ON repositories(is_active);
```

**Fields:**
- `id`: Primary key (UUID)
- `repo_fullname`: Full repository name (e.g., "owner/repo")
- `owner`: Repository owner
- `repo_name`: Repository name
- `default_branch`: Default branch name (usually 'main')
- `base_branch`: Base branch for PRs (usually 'main')
- `is_active`: Whether this repository is active
- `created_at`: Timestamp when repository was added
- `updated_at`: Timestamp when repository was last updated

### 2. `proposals`

Stores experiment proposals generated by the AI agent.

```sql
CREATE TABLE proposals (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  proposal_id TEXT UNIQUE NOT NULL,
  repo_id UUID REFERENCES repositories(id),
  idea_summary TEXT NOT NULL,
  rationale TEXT NOT NULL,
  expected_impact JSONB NOT NULL,
  technical_plan JSONB NOT NULL,
  category TEXT NOT NULL,
  confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'executing', 'completed')),
  update_block TEXT,
  oauth_session_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_proposals_proposal_id ON proposals(proposal_id);
CREATE INDEX idx_proposals_status ON proposals(status);
CREATE INDEX idx_proposals_created_at ON proposals(created_at DESC);

-- If the proposals table already exists without repo_id or update_block, add them:
-- ALTER TABLE proposals ADD COLUMN IF NOT EXISTS repo_id UUID REFERENCES repositories(id);
-- ALTER TABLE proposals ADD COLUMN IF NOT EXISTS update_block TEXT;
```

**Fields:**
- `id`: Primary key (UUID)
- `proposal_id`: Unique proposal identifier (e.g., "exp-001")
- `idea_summary`: Brief summary of the experiment idea
- `rationale`: Reasoning behind the proposal
- `expected_impact`: JSON object with `metric` and `delta_pct` keys
- `technical_plan`: JSON array of objects with `file` and `action` keys
- `category`: Category of the experiment (e.g., "checkout_optimization")
- `confidence`: Confidence score from 0.0 to 1.0
- `status`: Current status (pending, approved, rejected, executing, completed)
- `repo_id`: Foreign key to repositories table (optional, links proposal to a repo)
- `update_block`: Fast Apply format code update block (set when proposal is approved)
- `oauth_session_id`: Optional OAuth session ID
- `created_at`: Timestamp when proposal was created
- `updated_at`: Timestamp when proposal was last updated

### 2. `experiments`

Stores executed experiments (when a proposal is approved and run).

```sql
CREATE TABLE experiments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  proposal_id TEXT NOT NULL REFERENCES proposals(proposal_id),
  instruction TEXT NOT NULL,
  update_block TEXT NOT NULL,
  pr_url TEXT,
  branch TEXT,
  rollout_pct INTEGER DEFAULT 20 CHECK (rollout_pct >= 0 AND rollout_pct <= 100),
  status TEXT NOT NULL DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed', 'cancelled')),
  result_summary TEXT,
  metric_delta DECIMAL(10,6),
  result_data JSONB,
  oauth_session_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_experiments_proposal_id ON experiments(proposal_id);
CREATE INDEX idx_experiments_status ON experiments(status);
CREATE INDEX idx_experiments_created_at ON experiments(created_at DESC);
```

**Fields:**
- `id`: Primary key (UUID)
- `proposal_id`: Foreign key to proposals table
- `instruction`: Natural language instruction for the experiment
- `update_block`: Fast Apply format code update block
- `pr_url`: GitHub PR URL (set after PR is created)
- `branch`: Git branch name
- `rollout_pct`: Rollout percentage (0-100)
- `status`: Current status (running, completed, failed, cancelled)
- `result_summary`: Summary of experiment results
- `metric_delta`: Metric change percentage
- `result_data`: Additional result data (JSON)
- `oauth_session_id`: Optional OAuth session ID
- `created_at`: Timestamp when experiment was created
- `updated_at`: Timestamp when experiment was last updated

### 3. `activity_logs`

Stores activity logs for tracking system events.

```sql
CREATE TABLE activity_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  message TEXT NOT NULL,
  proposal_id TEXT,
  experiment_id UUID REFERENCES experiments(id) ON DELETE CASCADE,
  log_type TEXT NOT NULL DEFAULT 'info' CHECK (log_type IN ('info', 'success', 'warning', 'error')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_activity_logs_proposal_id ON activity_logs(proposal_id);
CREATE INDEX idx_activity_logs_experiment_id ON activity_logs(experiment_id);
CREATE INDEX idx_activity_logs_created_at ON activity_logs(created_at DESC);
CREATE INDEX idx_activity_logs_log_type ON activity_logs(log_type);
```

**Fields:**
- `id`: Primary key (UUID)
- `message`: Log message
- `proposal_id`: Optional reference to proposal
- `experiment_id`: Optional foreign key to experiments
- `log_type`: Type of log (info, success, warning, error)
- `created_at`: Timestamp when log was created

## Row Level Security (RLS)

You can set up RLS policies based on your authentication needs. Here are example policies:

```sql
-- Enable RLS (optional - if you want RLS enabled)
ALTER TABLE repositories ENABLE ROW LEVEL SECURITY;
ALTER TABLE proposals ENABLE ROW LEVEL SECURITY;
ALTER TABLE experiments ENABLE ROW LEVEL SECURITY;
ALTER TABLE activity_logs ENABLE ROW LEVEL SECURITY;

-- Option 1: Allow service role full access (RECOMMENDED for backend)
-- Note: When using service role key, RLS is bypassed by default, but these policies ensure compatibility
CREATE POLICY "Service role full access repositories" ON repositories 
  FOR ALL 
  USING (auth.jwt()->>'role' = 'service_role');

CREATE POLICY "Service role full access proposals" ON proposals 
  FOR ALL 
  USING (auth.jwt()->>'role' = 'service_role');

CREATE POLICY "Service role full access experiments" ON experiments 
  FOR ALL 
  USING (auth.jwt()->>'role' = 'service_role');

CREATE POLICY "Service role full access activity_logs" ON activity_logs 
  FOR ALL 
  USING (auth.jwt()->>'role' = 'service_role');

-- Option 2: Allow all operations if using service role key (alternative)
-- Or simply disable RLS for service role operations by allowing all for service_role
CREATE POLICY "Allow all for service role repositories" ON repositories 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all for service role proposals" ON proposals 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all for service role experiments" ON experiments 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all for service role activity_logs" ON activity_logs 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

-- Option 3: Allow all operations if using service role (SIMPLEST for backend)
-- This works because service role key bypasses RLS anyway, but these policies
-- ensure compatibility and avoid errors
DROP POLICY IF EXISTS "Allow all operations on repositories" ON repositories;
DROP POLICY IF EXISTS "Allow all operations on proposals" ON proposals;
DROP POLICY IF EXISTS "Allow all operations on experiments" ON experiments;
DROP POLICY IF EXISTS "Allow all operations on activity_logs" ON activity_logs;

CREATE POLICY "Allow all operations on repositories" ON repositories 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all operations on proposals" ON proposals 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all operations on experiments" ON experiments 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

CREATE POLICY "Allow all operations on activity_logs" ON activity_logs 
  FOR ALL 
  USING (true)
  WITH CHECK (true);

-- Option 4: If RLS is causing issues, you can disable it for backend tables
-- (Only do this if you're using service role key and want full access)
-- ALTER TABLE repositories DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE proposals DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE experiments DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE activity_logs DISABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read (adjust based on your auth needs)
CREATE POLICY "Authenticated users can read repositories" ON repositories 
  FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can read proposals" ON proposals 
  FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can read experiments" ON experiments 
  FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can read activity_logs" ON activity_logs 
  FOR SELECT 
  USING (auth.role() = 'authenticated');
```

## Setup Instructions

1. **Create the tables**: Run the SQL statements above in your Supabase SQL editor

2. **Set up environment variables** in your `.env` file:
   ```
   SUPABASE_URL=your_supabase_project_url
   SUPABASE_SERVICE_ROLE_KEY=your_service_role_key  # Recommended for backend
   # OR
   SUPABASE_ANON_KEY=your_anon_key  # Alternative, but requires proper RLS policies
   ```

3. **Install dependencies**:
   ```bash
   uv sync
   ```

4. **Verify connection**: The backend will automatically connect to Supabase on startup.

## Notes

- The backend uses `SUPABASE_SERVICE_ROLE_KEY` if available, which bypasses RLS policies
- If using `SUPABASE_ANON_KEY`, ensure RLS policies allow backend operations
- All timestamps are stored in UTC
- JSON fields (JSONB) are used for flexible data structures
- Foreign key constraints ensure data integrity between proposals and experiments

